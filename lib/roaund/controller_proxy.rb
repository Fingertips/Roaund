require 'cgi'
require 'uri'
require 'base64'
require 'openssl'

class Roaund
  class ControllerProxy
    # Allow client and server time to drift five minutes
    MAX_CLOCK_DRIFT = 60 * 5 
    
    attr_accessor :consumer_secret, :token_secret
    
    def initialize(controller)
      @controller = controller
      @request    = controller.request
    end
    
    def authorization
      @request.env['HTTP_AUTHORIZATION']
    end
    
    def authorization_params
      @authorization_params ||= Roaund::Headers.parse_authorization(authorization)
    end
    
    def get_params
      Roaund::URI.parse_query(@request.query_string)
    end
    
    def post_params
      Roaund::URI.parse_query(@request.raw_post)
    end
    
    def _oauth_params
      sources = [] 
      sources << get_params
      sources << post_params if @request.form_data?
      sources << authorization_params
      
      oauth_params = {}
      sources.each do |source|
        source.each do |key, value|
          if key.to_s.start_with?('oauth_')
            oauth_params[key] = value
          end
        end
      end; oauth_params
    end
    
    def oauth_params
      @oauth_params ||= _oauth_params
    end
    
    def request_method
      @request.request_method
    end
    
    def host
      default_port = @request.ssl? ? 443 : 80
      @request.port == default_port ? @request.host : @request.host_with_port
    end
    
    def base_uri
      "#{@request.scheme.downcase}://#{host.downcase}#{@request.path}"
    end
    
    def parameters
      parameters = []
      parameters.concat(authorization_params.except('realm').to_a)
      parameters.concat(get_params)
      parameters.concat(post_params) if @request.form_data?
      parameters.select { |key, value| key != 'oauth_signature' }
    end
    
    def compute_signature
      case oauth_params['oauth_signature_method']
      when 'HMAC-SHA1'
        signature = Roaund::Signature.new(request_method, base_uri, parameters)
        signature.compute_hmac_sha1_signature(consumer_secret, token_secret)
      else
        raise Roaund::UnsupportedSignature, "We don't support the #{oauth_params['oauth_signature_method']} signature method"
      end
    end
    
    def signature
      if @signature.nil?
        @signature = compute_signature
        Roaund.logger.debug("OAuth: Computed signature: #{@signature}")
      end; @signature
    end
    
    def valid_signature?
      case oauth_params['oauth_signature_method']
      when 'HMAC-SHA1'
        # Recalculating the request signature independently as described in
        # Section 3.4 and comparing it to the value received from the client
        # via the "oauth_signature" parameter.
        Roaund.logger.debug("OAuth: Got signature: #{oauth_params['oauth_signature']}")
        oauth_params['oauth_signature'] == signature
      when 'PLAINTEXT'
        # The "PLAINTEXT" method does not employ a signature algorithm.  It
        # MUST be used with a transport-layer mechanism such as TLS or SSL (or
        # sent over a secure channel with equivalent protections).  It does not
        # utilize the signature base string or the "oauth_timestamp" and
        # "oauth_nonce" parameters.
        oauth_params['oauth_signature'] == Roaund::Signature.key(consumer_secret, token_secret)
      end
    end
    
    def valid_timestamp?
      # To avoid the need to retain an infinite number of nonce values for
      # future checks, servers MAY choose to restrict the time period after
      # which a request with an old timestamp is rejected.
      if oauth_params['oauth_timestamp']
        timestamp = oauth_params['oauth_timestamp'].to_i
        if (Time.now.to_i - timestamp).abs > MAX_CLOCK_DRIFT
          Roaund.logger.info("OAuth: Request has a timestamp which differs more than 5 minutes from the server time (#{oauth_params['oauth_timestamp']})")
          return false if Roaund.strict?
        end
      end; true
    end
    
    def valid_nonce?
      # A nonce is a random string, uniquely generated by the client to allow
      # the server to verify that a request has never been made before and
      # helps prevent replay attacks when requests are made over a non-secure
      # channel.  The nonce value MUST be unique across all requests with the
      # same timestamp, client credentials, and token combinations.
      if oauth_params['oauth_nonce']
        if Roaund.nonce_store.exist?(oauth_params['oauth_nonce'])
          Roaund.logger.info("OAuth: Request has a nonce that was used before (#{oauth_params['oauth_nonce']})")
          return false if Roaund.strict?
        else
          Roaund.nonce_store.store(oauth_params['oauth_nonce'])
        end
      end; true
    end
    
    def no_replay?
      # If using the "HMAC-SHA1" or "RSA-SHA1" signature methods, ensuring
      # that the combination of nonce/timestamp/token (if present)
      # received from the client has not been used before in a previous
      # request (the server MAY reject requests with stale timestamps as
      # described in Section 3.3).
      
      if %w(HMAC-SHA1 RSA-SHA1).include?(oauth_params['oauth_signature_method'])
        return valid_timestamp? && valid_nonce?
      end
      
      true
    end
    
    def matches_scope?
      # If a token is present, verifying the scope and status of the
      # client authorization as represented by the token (the server MAY
      # choose to restrict token usage to the client to which it was
      # issued).
      
      # TODO: implement a callback structure to allow an implementation to
      # test more features like client and realm
      
      true
    end
    
    def valid_version?
      oauth_params['oauth_version'].blank? || (oauth_params['oauth_version'] == '1.0')
    end
    
    def valid?
      Roaund.logger.debug("OAuth: Checking validity of the request: signature #{valid_signature?}, no replay #{no_replay?}, matches scope #{matches_scope?}, valid version #{valid_version?}")
      valid_signature? && no_replay? && matches_scope? && valid_version?
    end
    
    # Returns true if this was a request with an OAuth Authorization
    # header with proper credentials.
    def present?
      !oauth_params.keys.empty?
    end
    
    # Yields the oauth_token if the current request contains and OAuth
    # Authorization header. Does not yield for non-OAuth request.
    #
    # The passed block should return an object that responds to
    # #token, #secret, #consumer_key, and #consumer_key_secret.
    #
    # Make sure that #token_secret returns either nil or a blank
    # String when authenticating temporary credentials.
    #
    # When the OAuth request is valid the method will return the object
    # returned from the block
    def authenticate_token(&block)
      if present? && entity = block.call(oauth_params['oauth_token'])
        self.consumer_secret = entity.consumer_key_secret
        self.token_secret = entity.secret
        return entity if valid?
      end; nil
    end
    
    # Yields the consumer_token if the current request contains and OAuth
    # Authorization header. Does not yield for non-OAuth request.
    #
    # The passed block should return an object that responds to
    # #key, #secret. These methods should return the consumer_token
    # and consumer_token_secret.
    #
    # When the OAuth request is valid the method will return the object
    # returned from the block
    def authenticate_consumer(&block)
      if present? && entity = block.call(oauth_params['oauth_consumer_key'])
        self.consumer_secret = entity.secret
        return entity if valid?
      end; nil
    end
  end
end